---
title: "Linux Bootcamp"
author: "Pavlo Hrab"
date: "4/14/2021"
output:
  html_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Основи роботи із терміналом
Термінал - це програма, котра запускає оболонку (shell) для Linux (bash, zsh, etc), котра дозволяє виконувати різноманітні програми. Більшість біоінформатичних задач виконується через нього. Це пов'язано зокрема із його гнучкістю та "простотою". Це осердя роботи на Linux.

Які причини вивчення його азів? Перша причина - це більшість біоінформатичних утиліт із відкритим кодом запускаються через командний рядок. Тобто, аби виконати state-of-the-art аналіз, на тому чи інщому етапі діло дійде до запуску програми із терміналу. Так, існують аналоги із графічним інтерфейсом (які інколи запускаються на віндовс), проте вони як правило a.) Платні b.) Повільні та не настільки гнучкі c.) В своїй основі - це ті ж утиліти з відкритим програмним кодом. Проте в такому разі ви перекладаєте відповідальність на оновлення програмного забезпечення з відкритим вихідним кодом, що лежить в ядрі програми, а також на вибір функцій, котрі ви можете використовувати, на "підтримувача" використовуваної програми з графічним інтерфейсом. Часто-густо біоінформатичні застосунки такого гатунку доходять до версії 1.0, а далі не підтримуються та не оновлюються. Тому завжди хороша ідея відмовитись від графічного інтерфейсу де це можливо та використовувати безпосередньо програму із командного рядка.
Інша причина - ці програми, що є  "золотим стандартом", пристосовані також для запуску на високопродуктивних комп'ютерних кластерах. А вони як правило використовують лінукс як операційну систему.
Лінукс швидкий. Також це система із відкритим вихідним кодом, котру кожен може використовувати. Тобто дослідник не повинен купляти ще й операційну систему (як-от Віндовс) для проведення аналізу.

Зокрема, давайте почнемо із основ використання терміналу і я сподіваюсь, що в кінці я зможу показати оцю "зручність, гнучкість та простоту" в цих аналізах

Отож, при першому запуску терміналу, справа, перед мигаючим курсором, вказано ім'я цього комп'ютера, та папка в котрій ви знаходитесь. Знак `~` вказує на так звану домашню папку (директорію). Для того аби в терміналі глянути котрі файли знаходяться в цій папці можна використати команду `ls`


```{bash}
ls
```
Зорема в папці, в котрій я знаходжусь на даних момент є лише 2 файли - .Rmd (текст котрий я пишу саме зараз у так званому форматі R Markdown) та .Rproj (файл проекту R.). Аби отримати більше інформації, ми можемо використовувати різні параметри для цієї програми (так звані "flags").  Використовуючи ті чи інші параметри, ми модифікуємо вихід програми (output). Наприклад параметр `-l` (list) дозволяє проаналізувати файли більш повно

```{bash}
ls -l
```
Тут кожен рядок - це окремий файл. Перші дефіси та букви - це набори дозволів для кожного файлу. Далі йдуть власники цих файлів, розмір в байтах, дата їх модифікації,та назва самого файлу. Ми не будемо вдаватись в подробиці щодо йього виходу, оскільки основна мета цього документа - дати мінімально необхідні практичні навички для проведення бласту, а не розказати про всі аспекти роботи в лінукс. Для більш детального ознайомлення із аспектами роботи в терміналі для біологів дивіться деінде. (Див секцію Ресурси в кінці документу.)

Із наведеного вище результату мабуть найбільш потрібною частиною є розмір файлу та дата його модифікації. Якшо із датою модифікації все зрозуміло, то із збільшенням розмірів файлів, розмір у байтах стає все менш інформативним. 

```{bash}
ls -lh
```
`-h` (human readable) параметр доволяє конвертувати байти в кіло-, мега-, та гігабайти (ну і далі). Так читати розмір файлу набагато простіше.
Звідки ж нам відомі ці параметри? Програми (утиліти) варто просто знати. Проте якщо кожна із програм має десь із десяток параметрів, то кількість програм + параметрів, що потрібно запам'ятати, швидко стане просто неймовірною. На щастя, кожна із програм має `-h` або `--help` параметр, котрий виводить в термінал опис усіх можливих параметрів та що вони роблять. Наприклід для `ls` :

```{bash}
ls --help | head
```
Також, якщо ви не знаєте що робити із тією чи іншою програмою, то майже кожна із них має мануал. Його можна викликати із терміналу командою  `man <програма-що-цікавить>`:
```{bash}
man ls | head
```
Вище наведено лише невелику частину мануалу для `ls`.  В цих прикладах ми також використали так звані pipes (труби?, ланцюжки аналізу? Без поняття як перекласти цей термін). Фактично, це з'єднання між собою програм так, що вихід одної програми стає входом іншої. Це основна сила терміналу. Оскільки можна аналізувати величезні файли, без запису проміжних результатів (що повільно), без відкриття/закриття файлів (що теж повільно) та зі збереженням місця на диску. Більше силу цих ланцюжків, буде показано потім. У прикладі вище, ми перенаправили виходи програм в команду `head`, що виводить лише перші 10 рядків. Аналогічно можна використовувати команду `tail` щоб вивести 10 останніх рядків
```{bash}
man ls | tail
```


Отож завжди варто користоватись `-h | --help` параметрами, коли не зрозуміло як програми працює, як потрібно подавати вхідні чи вихідні файли.

Окрім `ls` ще є плеора інших програм. Наприклад `pwd` доволяє поглянути в якій ви директрорії знаходитесь 
```{bash}
pwd
```
`cd` - доволяє переміщатись між папками, а `mkdir` - їх створювати. Накприклад давайте створимо папку 'test' та файл 'test.txt'. Потім перейдемо в цю папку
```{bash}
mkdir test
cd test
pwd
```
Аби повернутись в папку вверх можна використати `..` в команді cd.
```{bash}
ls
echo "###############"
cd ..
pwd
echo "###############"
cd training/test
ls
pwd
echo "###############"
cd ../..
pwd
```
Отож ми працюємо із папки, де знаходиться цей документ. Ми перелічили файли - це 2 початкові файли + новостворена папка test. Команда `echo` - просто виводить текст котрий є в лапках в термінал. Тут використав просто для розмежування виходів програм. Далі ми вернулись на папку наверх. Це підтверджено командою pwd (знаходимось в папці /home/pavloh). Далі ми пейшли в папку test, перелічили файли (виходу немає, оскільки файлів немає), і вернулись назад.

Пропоную створиnи файл test.txt командою `touch`, що дозволяє створювати пусті файли
```{bash}
touch test/test.txt
ls test
```
Файл ми створили. Також можна не переходити до папкм test, аби створити там файл. Можна просто вказати так званий відносний шлях від папки в котрій ви знаходитесь (абсолютним шляхом буде /home/pavloh/training/test). Якщо ви не знаєте в котрій папці ви знаходитесь, використайте `pwd`. Для запису будь-чого в цей файл, варто спочатку ввести концепцію перенаправлення виходу із терміналу у файл. Так знак `>` перенаправляє вихід із терміналу у файл, повністю його переписуючи (якщо він існує), або створюючи та записуючи (якщо такого файлу немає). Знак `>>` додає до існуючого файла в кінець, вихід команди. 
Наприклад наступна частина коду замість того аби виводити `Hello world!` в термінал, просто записує у файл test/test.txt. Якщо такого файлу  не існує його буде створено.
```{bash}
echo "Hello world!" > test/test.txt
```

Аби переконатись, що контент нашого файлу змінився ми можемо використати команду `cat`, щоб вивести вміст бажаного файлу у термінал
```{bash}
cat test/test.txt
```
Результат - один рядок "Hello world!". Можна безкінечно запускати попередню команду (echo....) із cat і результат не змінюється, тому файл перезаписується. Якщо ж замінитит знак `>` на `>>`, то кількість рядків у файлі test.txt збільшуватиметься із кожним запуском 
```{bash}
echo "Hello world!" >> test/test.txt && cat test/test.txt
```
Також ми замість того, аби запускати команди окремими рядками, пов'язали між собою `&&`. Загалом `&&` означає виконувати наступну команду лише коли попередня успішно (без помилок) завершилась, `||` - виконувати команду лише коли попередня завершилась помилкою, `;` - виконувати команду незалежно від стану завершення попередньої. Тобто у цьому прикладі ми вказали вивести вміст файла test.txt в термінал, тільки якщо попередня команда була успішна.
```{bash}
echo "Hello world!" >> tast/test.txt || cat test/test.txt
```
Тут ми неправильно вказали папку, тому команда завершилась помилкою (такої папки не існує), проте контент файлу видимий в терміналі (через `||` зв'язок).

Для того аби такого не трапилось, варто завжди використовувати автозаповнення (натисніть Tab при початку друку папки/файлу. Тоді назва автодоповниться. Це зберігає силу-силенну часу).

Коли ми завершили роботу з файлами, то можемо використати `rm` для їх видалення. Проте ми не можемо видалити цілу папку (якщо вона не пуста). Для видалення папки та всього її контенту можна використати `-r` (рекурсивно) параметр
```{bash}
rm -r test
ls
```
Папки test та всього її контенту немає. **Обережно. Видалення файлів необоротнє! Linux також дозволяє вам видаляти та змінювати системні файли без ніяких запитань. Тому будь-які видалення непоротні та мають бути виконані з обережністю...**

Іншим вітальним аспектом роботи в терміналі, котрий буде розлянуто в цій секції - це відкриття вбудованого текстового редактора. Так `less` дозволяє відкривати файли в терміналі та перегляди їх вміст без його зміни (для того аби вийти із редактора натисніть клавішу q ). Іншим інтуїтивним редактором є `nano`. Проте він як правило не превстановлений, тому це потрібно зробити самостійно. (наступний розділ)

Інші аспекти роботи з терміналом буде розглянуто в світлі запуску бласту. Проте все ж тут не було висвітлено аспекти роботи з архівами, повноцінного використання `ssh`, `awk` `parallel`, та з десятка інших програм (цикли, умови if/else). Будь ласка використайте згадані тут ресурси для більш повного ознайомлення із Лінуксом.

## Встановлення програм
Загалом встановлення програм на лінукс досить просте - варто лише дізнатись файловий менеджер для встановленого дистрибутиву. Встановлення також відбувається із з-під так званого суперюзера - тобто особи, котра може встановлювати, видаляти та маніпулювати всіма файлами системи. Аби виконати програму з-під суперюзера варто просто додати `sudo` перед самою командою та ввести пароль. **Важливо** пароль не буде надруковано в терміналі при його введенні (з питань безпеки, проте введення відбувається), а його встановлення - це один із етапів встановлення операційної системи.
Для Ubuntu файловий менеджер - це apt (apt-get), для Fedora - це yum, для Arch - це pacman. Отож, аби встановити будь-яку програму (на Ubuntu наприклад), варто ввести в терміналі:

```
sudo apt-get install <назва-програми>
```

Тобто щоб встановити бласт потрібно прогнати:
```
sudo apt-get install ncbi-blast+
```
Якщо виникає помилка, то ймовірно потрібно оновити репозиторії (а краще цілу систему) :
```
sudo apt-get update && sudo apt-get upgrade
```
А вже після цього встановити blast+.

# Приклад запуску бласту

Для початку змоделюємо ситуацію. Автори статті проаналізували набори генів-транспортерів в певних можельних бактеріях продуцентах антибіотиків (Streptomyces coelicolor наприклад). Ви працюєте із тим же родом, проте із немодельним видом/іншим штамом. Ваше завдання - знайти набір гомологів у вашому штамі.

Дані адаптовано із:

```
Zhou, Z., Sun, N., Wu, S., Li, Y. Q., & Wang, Y. (2016). Genomic data mining reveals a rich repertoire of transport proteins in Streptomyces. BMC genomics, 17 Suppl 7(Suppl 7), 510. https://doi.org/10.1186/s12864-016-2899-4
```

Вихідні дані для нашого аналізу включають:

1. Текстовий файл із переліком транспортерів в S.coelicolor (модельний організм). Дано SCO номери, що фактично є локус тагами.
2. Протеом у фаста форматі S.coelicolor. Назви білків - це SCO номери
3. Протеом Streptomyces seoulensis KCTC 9819. Номери доступу NZ_CP032229.1/NZ_CP032230.1 . Це наш немодельний організм, гомологи транспортерів в котрому ми хочемо знайти.

**Важливо: увесь наступний аналіз грунтується на тому, що кожна послідовність у фаста файлі займає лише один рядок. Аби цього досягнути можна використати наступну команду** 

```
awk '/^>/ {printf("\n%s\n",$0);next; } { printf("%s",$0);}  END {printf("\n");}' < "вхідний-файл" > "вихідний-файл"
```

Отож, досить часто результати в статті науковці подають у формі excel файлу. В нашому випадку цей файл містив дані ідентифікованих транспортерів для кількох модельних стрептоміцет. 
Для підготовки текстового файлу SCO номерів, відповідна колонка із таблиці була просто скопійована. Взято лише частина виявлених авторами транспортерів (Канали/Пори (Channels/Poers)) для пришвидшення аналізу.

Виходячи із даних нам потрібно зробити такі кроки:

0. Завантажити дані
1. Виконати препроцессинг даних. Хорошою практикою буде видалення усіх пробілів, оскільки тоді при бластуванні назви білків не буде "розірвано"
2. Витягнути послідовності транспортерів із протеому S.coelicolor.
3. Підготувати бази для бласту із геномів S.coelicolor та S.seoulensis
4. Прямий бласт. Знайти всі гомологи у вибраній базі
5. Реципрокний бласт. 1-1 ортологія

## Крок 0. Завантаження даних.
Для завантаження даних можна використовувати команду `wget`, після котрої йде посилання на завантаження. Хорошою практикою буде також зробити нову папку та проводити аналіз в ній.

```{bash include=FALSE}
# зробімо нову папку для аналізу, та завантажемо дані туди
mkdir blast && cd blast
wget https://raw.githubusercontent.com/pavlohrab/blast_training/main/S.seoulensis.fasta
wget https://raw.githubusercontent.com/pavlohrab/blast_training/main/S.coelicolor.fasta
wget https://raw.githubusercontent.com/pavlohrab/blast_training/main/SCO_numbers.txt

```

## Крок 1. Препроцессинг даних
Оскільки дані було підготовлено, то кожна послідовність знаходиться в одному рядку, а також назви було спеціально почищено (просто короткі локус таги). 

Проте завжди варто переглядати чи немає пробілів у назвах послідовностей -> їх варто уникати. Для того, аби знайти будь-що у текстовому файлі, потужним інструментом постає команда `grep`. Вона не лише виводить рядки, що містять точну відповідність шуканому "слову", проте також підтримує регулярні вирази, що значно розширює її можливості. Більше про регулярні вирази [тут](https://regexone.com) або [тут](https://regexr.com)
Зокрема давайте знайдемо усі пробіли у файлах
```{bash}
# -с параметр означає не виводити рядки, а лише поразувати кількість хітів
cat blast/S.coelicolor.fasta | grep -c " "
cat blast/S.seoulensis.fasta | grep -c " "
```
Отож, S.coelicolor містить один хіт, в той час як S.seoulensis 5600. Давайте поглянемо на ці хіти

```{bash}
# -A та -B параметри вказують скільки ряжків перед (Before) та після (After) хіта виводити в термінал. Ми це робимо аби зрозуміти контест в котрому опинився пробіл
cat blast/S.coelicolor.fasta | grep -A1 -B1 " "
echo "################"
# Тут виводимо перші 6 рядків, що містять хіти (немає сенсу в 5600+ рядках)
cat blast/S.seoulensis.fasta | grep  " " | head
```
Таке враження, що в геномі S.coelicor пробіл можемо ігнорувати, оскільки він знахоться або в проміжку між послідовностями, або ж після такої. Це не впливає на результати аналізу. Випадок S.seoulensis важчий, оскільки виявляється, що ідентифікатори послідовностей розділені пробілом. Під час бласту тільки перша частина буде занесена в таблицю (що однакова для всіх послідовностей), тому результати не матимуть змісту. Нам варто замінити пробіл на, скажімо, `_`. Тоді результати міститимуть справді унікальні ідентифікатори.
Аби це зробити використаймо команду `sed`. Це досить потужна команда, що досволяє заміняти частини тескту на інші (регулярні вирази теж підтримуються). Основна логіка використання наступна `sed 's/що-замінити/на-що-замінити/g файл-входу > файл-результату'` .
```{bash}
sed 's/ /_/g' blast/S.seoulensis.fasta > blast/S.seoulensis_clean.fasta
```

Давайте поглянемо чи пробіли замінились
```{bash}
# Шукаємо пробіли
cat blast/S.seoulensis_clean.fasta | grep  " " 
# Шукаємо _
cat blast/S.seoulensis_clean.fasta | grep  "_"  | head
```
Так, пробіли і справді замінились на `_`

## Крок 2. Витягуємо послідовності транспортерів із протеому S.coelicolor

Саме для цього кроку варто було мати послідовності у фаста форматі, коли одна послідовність займає один рядок. В такому разі, ми можемо використати `grep` із параметром `-A1`, що дозволить витягнути рядок за хітом (хіт - це назва послідовності, а ряжок за хітом - це сама послідовність). Оскільки дані приготовлено так, що номери зі статті точно відповідають назвам послідовності, нам потібно ще вказати `-F` параметр. Він каже програмі, аби читати текст як є. Тобто усі спеціальні знаки, які використовуються в регулярних виразах, буде проігноровано. Цей параметр завжди варто вказувати, аби уникнути непорозумінь, якщо шуканий термін, точно відповідає такому в тексті і ви не використовуєте регулярні вирази. Останнім параметром, котрий варто вказати є `-f blast/SCO_numbers.txt`. Цей параметр вказує, що терміни для пошуку є у файлі, (один термін - один рядок). Тому ми не маємо вказувати їх в лапках як вище. Отож, аби витягнути послідовності транспортерів із протеому S.coelicolor:

```{bash}
# Ми використовуємо sed аби позбутись від -- рядка в кінцевому файлі
grep -F -f blast/SCO_numbers.txt -A1 blast/S.coelicolor.fasta | sed "s/^--//g"  > blast/SCO_transporters.fasta
cat blast/SCO_transporters.fasta | head -n 5
```
Отож ми успішно витягнули послідовності, котрі будемо використовувати як query при бласті.

## Крок 3. Створення бази бласту
Наступні кроки (ті що стосуються бласту), - це використання команд, котрі були встановлені, використовуючи `sudo apt-get install ...` . Зокрема для створення бази даних варто використати команду 


```{bash}
makeblastdb -in blast/S.seoulensis_clean.fasta -dbtype prot
```

Де `-in` вказує на файл, із котрого потрібно зробити базу, а `-dbtype` - на тип даних. В нас - це білкові послідовності, тому ми вказали prot. В папці blast появились додаткові файли, котрі необхідні для бласту супроти бази даних, проте ми не будемо їх використовувати напряму.

## Крок 4. Прямий бласт
Для бласту існує кілька різних програм. Зокрема `blastp` `blastn`,`blastx`, `tblastn`, `tblastx`, детальний опис який наведено деінде (наприклад [тут](https://blast.ncbi.nlm.nih.gov/Blast.cgi)).

Для пошуку білкових послідовностей в протеомі ми використаємо `blastp`.

```{bash}
blastp -h
```
Зокрема мінімальний запуск виглядає наступним чином:
```{bash}
blastp -query blast/SCO_transporters.fasta  -db blast/S.seoulensis_clean.fasta -out blast/S.seoulensis_transport.txt
cat blast/S.seoulensis_transport.txt | head -n 60
```
Відкритий файл - це фактично стандартний вихід бласту. Він досить просто читається людьми, проте профільтрувати його програмним шляхом значно складніше. Саме тому хорошим рішенням є вивести результат у вигляді таблиці, котра займає менше місця на диску, та яку ще й можна програмно прочитатии та проаналізувати. Також бласт можна виконувати вже із зазначеними фільтрами (найбільш поширеним із котрих є E-value). Якщо вказати фільтри при самому запуску програми, то й сам процес відбудеться значно швидше. (частина хітів просто відсікається)

Наприклад

```{bash}
blastp -query blast/SCO_transporters.fasta  -db blast/S.seoulensis_clean.fasta -out blast/S.seoulensis_transport_table.txt -outfmt 6 -evalue 1e-10 -qcov_hsp_perc 0.5
cat blast/S.seoulensis_transport_table.txt | head 
```
Зокрема що саме означає кожна колонка детально розписано [тут](https://www.biostars.org/p/88944/) у відповідях до питання. (а також які формати від якою цифрою та як додати колонки (вихід результату) до `-outfmt 6`). 
Проте головне, що тепер в нас є результати бласту в табличному форматі, вже із E-value < 1e-10 та відсотком вирівнюванням SCO білка до відповідного хіта > 50%. Тобто фактично це "чисті" результати пошуку гомологів. 

**Помітка - друга колонка складалась тільки із D0Z67 , якщо ми б не замінили пробіл на _ в кроці 0. Можете проробити кроки 3 та 4 із файлом S.seoulensis.fasta замість S.seoulensis_clean.fasta**

Фактично якщо завдання стоїть знайти усіх транспортерів у вибраному геномі (в нашому прикладі білків-каналів), то не варто використовувати результати реципрокного бласту.

### Суть реципрокного бласту
Два білки вважаються гомологами, якщо при прямому бласті (білок із геному 1 супроти геному 2) і при реципрокному бласті (білок-хіт із геному 2 із результатів прямого бласту супроти геному 1) вони залишаються найкращими хітами. 
Тобто при балстуванні Білка-1 супроти геному-2, найкращим хітом вийшов Білок-2, а при бластуванні Білка-2 супроти геному-1 -> Білок-1.
В цій концепції є кілька проблем. Зокрема, а що якщо Білок-3 (із геному 2) не є найкращим хітом в ніякому випадку, проте його можна вважати паралогом Білка-2? Якщо ми використовуємо результати лише реципрокно найкращих хітів, то упускаємо цей Білок-3. 
Саме тому краще зібрати всі ймовірні хіти в геномі-2, а потім вже пробувати встановити 1-1 зв'язки. Або "one-to-many"/"many-to-one".

### Створення фаста файлу знайдених транспортерів
Отож ми знайшли хіти при бласті. Проте ми очікуємо досить високий відсоток дуплікації в результатах (перекривання результатів) для S.seoulensis. Оскільки ми шукаємо транспортери, котрі мають певних відсоток подібності в геномі, то це стосуватиметься і результатів бласту. 
Отож для творення фаста файлу потрібні такі кроки:

1. Відкинути дупліковані результати
2. Помістити назви білків у файл
3. Використати цей файл для пошуку та витягнення послідовностей, аналогічно до кроку 2

1. 
```{bash}
cat blast/S.seoulensis_transport_table.txt | awk -F '\t' '{print $2}'|sort -u > blast/S.seoulensis_numbers.txt
```
Тут ми відкриваємо результати бласту, виділяємо другу колонку з awk (awk, то насправді невелика мова програмування, з нею можна робити багато крутих речей фактично із терміналу та в один рядок. Тут ми це опускаємо), сортуємо (команда `sort`) та залишаємо лише унікальні значення (параметр `-u`). Можете поекспериментувати, із та без параметра `-u`. Які хіти знайдено кілька раз?

В результаті маємо 
```{bash}
wc -l blast/S.seoulensis_numbers.txt
```
116 транспортерів (білків-каналів), котрі гомологічні до таких в S.coelicolor. (`wc -l` рахує рядки у файлі). На противагу, ми шукали лише 
```{bash}
wc -l blast/SCO_numbers.txt
```
28 білків. Отож велика частина білків-каналів лишилась би поза аналізом, якщо б ми використовували лише результати реципрокного бласту.

**Проте варто зауважити, що є певна подібність серед транспортерів в одному геномі. Тому не можна стверджувати, що знайдені 116 білків - це лише білки-канали. Вірогідно серед них є також інші види транспортерів (ймовірно більше половини результатів - це не білки-канали). Проте це суб'єкт для вже іншого аналізу та класифікації (скажімо анотацією Pfam доменів)**

*Основна суть такого аналізу - це виловити усі можливі гомологи в геномі*

Для того, аби зробити фаста файл, потрібно знову ж таки використати `grep` (крок 2)
```{bash}
grep -F -f blast/S.seoulensis_numbers.txt -A1 blast/S.seoulensis_clean.fasta | sed "s/^--//g"  > blast/S.seoulensis_transporters.fasta
```


## Крок 5. Реципрокний бласт. 1-1 ортологія
Якщо завдання стоїть лише по пошуку 1-1 ортологів, то тут варто використати метод реципрокно найкращих хітів. (коротко описаний в кроці 4).
Для цього варто:

0. Виконати бласт у кроці 4, залишивши лише найкращий хіт. Зробити фаста файл
1. Зробити базу для бласту із геному S.coelicolor
2. Виконати бласт супроти геному S.coelicolor
3. Вручну (або написавши невеликий скрипт в іншій мові програмування) порівняти чи результати прямого бласту аналогічні до результатів реципрокного

0.
```{bash}
blastp -query blast/SCO_transporters.fasta  -db blast/S.seoulensis_clean.fasta -out blast/S.seoulensis_transport_table_1.txt -outfmt 6 -evalue 1e-10 -qcov_hsp_perc 0.5 -max_target_seqs 1
cat blast/S.seoulensis_transport_table_1.txt | awk -F '\t' '{print $2}'|sort -u > blast/S.seoulensis_numbers_1.txt
grep -F -f blast/S.seoulensis_numbers_1.txt -A1 blast/S.seoulensis_clean.fasta | sed "s/^--//g"  > blast/S.seoulensis_transporters_single.fasta
```
1. 
```{bash}
makeblastdb -in blast/S.coelicolor.fasta -dbtype prot
```

2.
```{bash}
blastp -query blast/S.seoulensis_transporters_single.fasta  -db blast/S.coelicolor.fasta -out blast/S.seoulensis_transport_table_reciprocal.txt -outfmt 6 -evalue 1e-10 -qcov_hsp_perc 0.5 -max_target_seqs 1
```
3.Відкрити таблиці в будь-якій зручній та переглянути чи результати аналогічні. Якщо так, то можна говорити про 1-1 ортологію.


**Загалом вихідні файли - це .tsv файли (тобто як делімітер використовується Tab (знак \t)). Саме тому розширення  не грає ролі, його можна потім змінити. Тут .txt, оскільки вони відкриваються на будь-якій системі.**

**Ще одним зі способів перегляду файлів - це використання текстових редакторів в терміналі. Один із таких редакторів - це `less`. Аби вийти із нього варто надрукувати `q`**

# Ресурси для більш детальшого ознайомлення 
Робота із терміналом в загальному:

1. [курс на FutureLearn](https://www.futurelearn.com/courses/linux-for-bioinformatics) 
2. [Туторіал](https://omicstutorials.com/getting-started-in-linux-bioinformatics/) 
3. [Туторіал 2](https://www.bits.vib.be/training-list/112-bits/training/upcoming-trainings/124-linux-for-bioinformatics). 
Книги про ефективне обчислення для біологів та використання програм із відкритим кодом:
1. [Computing skills for Biologists](https://www.amazon.com/Computing-Skills-Biologists-Stefano-Allesina/dp/0691182752) 
2. [Bioinformatics Data Skills: Reproducible and Robust Research with Open Source Tools](https://www.amazon.com/Bioinformatics-Data-Skills-Reproducible-Research/dp/1449367372)
3. [Biostars Handbook](https://www.biostarhandbook.com))
4. [Data Carpentry Genomics Workshop](https://datacarpentry.org/shell-genomics/)